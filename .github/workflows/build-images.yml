name: Build & Push Workspace Images

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      build_all:
        description: "Build all images (ignores change detection)"
        type: boolean
        default: false
      specific_images:
        description: "Build specific images (comma-separated, e.g. 'ubuntu-perseeva-backend,ubuntu-moneymentor')"
        type: string
        default: ""
  release:
    types: [published]

permissions:
  contents: read
  packages: write

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      folders: ${{ steps.detect.outputs.folders }}
      any: ${{ steps.detect.outputs.any }}
      build_all: ${{ steps.detect.outputs.build_all }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect image folders (Dockerfile present) + changed folders + dependency resolution
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          # Find all folders at repo root containing a Dockerfile
          mapfile -t ALL_DIRS < <(
            find . -maxdepth 2 -mindepth 2 -type f -name Dockerfile -printf '%h\n' \
              | sed 's|^\./||' \
              | awk -F/ '{print $1}' \
              | sort -u
          )

          if [ ${#ALL_DIRS[@]} -eq 0 ]; then
            echo "No Dockerfiles found."
            echo 'folders=[]' >> "$GITHUB_OUTPUT"
            echo "any=false" >> "$GITHUB_OUTPUT"
            echo "build_all=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          EVENT="${{ github.event_name }}"
          INPUT_BUILD_ALL="${{ github.event.inputs.build_all || 'false' }}"
          INPUT_SPECIFIC="${{ github.event.inputs.specific_images || '' }}"

          BUILD_ALL="false"
          if [ "$EVENT" = "workflow_dispatch" ] && [ "$INPUT_BUILD_ALL" = "true" ]; then
            BUILD_ALL="true"
          fi
          if [ "$EVENT" = "release" ]; then
            BUILD_ALL="true"
          fi

          # Handle specific images input - early exit with selected images
          if [ "$EVENT" = "workflow_dispatch" ] && [ -n "$INPUT_SPECIFIC" ]; then
            echo "Building specific images: $INPUT_SPECIFIC"
            SELECTED=()
            # Parse comma-separated list
            IFS=',' read -ra SPECIFIC_ARRAY <<< "$INPUT_SPECIFIC"
            for img in "${SPECIFIC_ARRAY[@]}"; do
              # Trim whitespace
              img=$(echo "$img" | xargs)
              # Validate the image exists
              if [ -f "$img/Dockerfile" ]; then
                SELECTED+=("$img")
              else
                echo "Warning: '$img' is not a valid image folder with Dockerfile, skipping."
              fi
            done

            if [ ${#SELECTED[@]} -eq 0 ]; then
              echo "No valid images specified."
              echo 'folders=[]' >> "$GITHUB_OUTPUT"
              echo "any=false" >> "$GITHUB_OUTPUT"
              echo "build_all=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Output JSON array
            JSON='['
            first=1
            for d in "${SELECTED[@]}"; do
              if [ $first -eq 0 ]; then JSON+=','; fi
              first=0
              JSON+="\"$d\""
            done
            JSON+=']'

            echo "Selected folders: ${SELECTED[*]}"
            echo "folders=$JSON" >> "$GITHUB_OUTPUT"
            echo "any=true" >> "$GITHUB_OUTPUT"
            echo "build_all=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build dependency graph: each image -> list of images that depend on it
          declare -A DEPENDS_ON  # image -> list of images that use it as base
          declare -A BASE_IMAGE  # image -> its base image (if any, relative path)
          
          for d in "${ALL_DIRS[@]}"; do
            if [ -f "$d/Dockerfile" ]; then
              # Extract the first FROM line (ignore comments/ARGs/syntax directives)
              FROM_LINE=$(awk 'toupper($1) == "FROM" {print; exit}' "$d/Dockerfile")
              if [ -n "$FROM_LINE" ]; then
                # Parse the base image name from FROM line
                BASE=$(echo "$FROM_LINE" | sed -E 's/^FROM[[:space:]]+([^[:space:]]+).*/\1/' | sed 's|:latest||')
                # Extract just the image name (no registry, no tag)
                BASE_NAME=$(basename "$BASE")
                # Map to our local image if it matches
                for other in "${ALL_DIRS[@]}"; do
                  if [[ "$BASE" == *"$other"* ]] || [[ "$BASE_NAME" == "$other" ]]; then
                    BASE_IMAGE["$d"]="$other"
                    DEPENDS_ON["$other"]+="$d "
                    break
                  fi
                done
              fi

              # Also detect COPY --from dependencies (for multi-stage copies from other images)
              while IFS= read -r COPY_LINE; do
                if [ -n "$COPY_LINE" ]; then
                  # Extract image from COPY --from=image
                  COPY_BASE=$(echo "$COPY_LINE" | sed -E 's/.*--from[[:space:]]*=?[[:space:]]*([^[:space:]]+).*/\1/' | sed 's|:latest||')
                  if [ -n "$COPY_BASE" ] && [[ "$COPY_BASE" != /* ]]; then
                    COPY_BASE_NAME=$(basename "$COPY_BASE")
                    for other in "${ALL_DIRS[@]}"; do
                      if [[ "$COPY_BASE" == *"$other"* ]] || [[ "$COPY_BASE_NAME" == "$other" ]]; then
                        # Add dependency (may already exist, that's fine)
                        if [[ ! " ${DEPENDS_ON[$other]} " =~ " $d " ]]; then
                          DEPENDS_ON["$other"]+="$d "
                        fi
                        break
                      fi
                    done
                  fi
                fi
              done < <(grep -E '^[[:space:]]*COPY[[:space:]]+.*--from' "$d/Dockerfile" || true)
            fi
          done

          # Debug: print dependency info
          echo "Dependency graph:"
          for img in "${!BASE_IMAGE[@]}"; do
            echo "  $img -> ${BASE_IMAGE[$img]}"
          done
          for base in "${!DEPENDS_ON[@]}"; do
            echo "  $base is used by: ${DEPENDS_ON[$base]}"
          done

          if [ "$BUILD_ALL" = "true" ]; then
            SELECTED=("${ALL_DIRS[@]}")
          else
            BEFORE="${{ github.event.before }}"
            AFTER="${{ github.sha }}"

            # Fallback if BEFORE is missing
            if [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
              BEFORE="$(git rev-list -n 1 "${AFTER}" 2>/dev/null || true)"
            fi

            if [ -z "$BEFORE" ]; then
              echo "Could not determine BEFORE commit; building all."
              SELECTED=("${ALL_DIRS[@]}")
            else
              mapfile -t CHANGED_FILES < <(git diff --name-only "$BEFORE" "$AFTER")
              mapfile -t CHANGED_TOP < <(printf "%s\n" "${CHANGED_FILES[@]}" | awk -F/ 'NF>1 {print $1}' | sort -u)

              SELECTED=()
              for d in "${CHANGED_TOP[@]}"; do
                if [ -f "$d/Dockerfile" ]; then
                  SELECTED+=("$d")
                fi
              done

              # Now add all images that depend on any selected base images
              # This is the key fix: when a base image is updated, also build dependents
              DEPENDENT_NEEDED=()
              for d in "${SELECTED[@]}"; do
                DEP_LIST=""
                if [[ -v "DEPENDS_ON[$d]" ]]; then
                  DEP_LIST="${DEPENDS_ON[$d]}"
                fi
                if [ -n "$DEP_LIST" ]; then
                  echo "Base image $d was changed, adding dependents: $DEP_LIST"
                  for dep in $DEP_LIST; do
                    # Check if this dependent is not already in SELECTED
                    ALREADY_SELECTED=0
                    for sel in "${SELECTED[@]}"; do
                      if [ "$sel" = "$dep" ]; then
                        ALREADY_SELECTED=1
                        break
                      fi
                    done
                    if [ $ALREADY_SELECTED -eq 0 ]; then
                      DEPENDENT_NEEDED+=("$dep")
                    fi
                  done
                fi
              done

              # Merge selected and dependents
              if [ ${#DEPENDENT_NEEDED[@]} -gt 0 ]; then
                SELECTED=("${SELECTED[@]}" "${DEPENDENT_NEEDED[@]}")
                echo "Added dependents to build: ${DEPENDENT_NEEDED[*]}"
              fi
            fi
          fi

          if [ ${#SELECTED[@]} -eq 0 ]; then
            echo "No image folders selected; nothing to build."
            echo 'folders=[]' >> "$GITHUB_OUTPUT"
            echo "any=false" >> "$GITHUB_OUTPUT"
            echo "build_all=$BUILD_ALL" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Output JSON array
          JSON='['
          first=1
          for d in "${SELECTED[@]}"; do
            if [ $first -eq 0 ]; then JSON+=','; fi
            first=0
            JSON+="\"$d\""
          done
          JSON+=']'

          echo "Selected folders: ${SELECTED[*]}"
          echo "folders=$JSON" >> "$GITHUB_OUTPUT"
          echo "any=true" >> "$GITHUB_OUTPUT"
          echo "build_all=$BUILD_ALL" >> "$GITHUB_OUTPUT"

  build:
    needs: detect
    if: needs.detect.outputs.any == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore base digest cache
        uses: actions/cache/restore@v4
        with:
          path: .build/base-digests.txt
          key: base-digests-${{ github.ref_name }}-${{ github.run_id }}
          restore-keys: |
            base-digests-${{ github.ref_name }}-
            base-digests-

      - name: Build selected images (base first) and push to GHCR
        shell: bash
        run: |
          set -euo pipefail

          OWNER_LC="$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"
          REPO_LC="workspace-images"
          PREFIX="ghcr.io/${OWNER_LC}/${REPO_LC}"

          # Parse selected folders
          FOLDERS='${{ needs.detect.outputs.folders }}'
          mapfile -t LIST < <(echo "$FOLDERS" | jq -r '.[]')

          # Order: base images first (convention: ends with -base or equals ubuntu-dev-base or ubuntu-rocksdb)
          BASES=()
          REST=()
          for f in "${LIST[@]}"; do
            if [[ "$f" == *"-base" ]] || [[ "$f" == "ubuntu-dev-base" ]] || [[ "$f" == "ubuntu-rocksdb" ]]; then
              BASES+=("$f")
            else
              REST+=("$f")
            fi
          done
          ORDER=("${BASES[@]}" "${REST[@]}")
          DIGEST_FILE=".build/base-digests.txt"
          mkdir -p "$(dirname "$DIGEST_FILE")"
          touch "$DIGEST_FILE"

          declare -A CACHED_DIGESTS
          while read -r img digest; do
            if [ -n "$img" ] && [ -n "$digest" ]; then
              CACHED_DIGESTS["$img"]="$digest"
            fi
          done < "$DIGEST_FILE"

          declare -A REMOTE_DIGESTS

          get_base_ref() {
            awk 'toupper($1) == "FROM" {print $2; exit}' "./$1/Dockerfile"
          }

          get_remote_digest() {
            local ref="$1"
            docker buildx imagetools inspect "$ref" | awk '/Digest:/ {print $2; exit}'
          }

          update_digest_cache() {
            local ref="$1"
            local digest="$2"
            if [ -z "$digest" ]; then
              return 0
            fi
            awk -v ref="$ref" '$1 != ref' "$DIGEST_FILE" > "${DIGEST_FILE}.tmp"
            printf "%s %s\n" "$ref" "$digest" >> "${DIGEST_FILE}.tmp"
            mv "${DIGEST_FILE}.tmp" "$DIGEST_FILE"
          }

          echo "Build order: ${ORDER[*]}"

          # Tagging strategy:
          # - latest always
          # - sha-<commit> always
          # - if this is a release, also add the release tag (e.g. v1.2.3)
          RELEASE_TAG=""
          if [ "${{ github.event_name }}" = "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
          fi

          for f in "${ORDER[@]}"; do
            IMAGE="${PREFIX}/${f}"
            echo "== Building ${IMAGE} from ./${f} =="

            TAG_ARGS=(--tag "${IMAGE}:latest" --tag "${IMAGE}:sha-${GITHUB_SHA}")

            if [ -n "$RELEASE_TAG" ]; then
              TAG_ARGS+=(--tag "${IMAGE}:${RELEASE_TAG}")
            fi
            PULL_ARG=()
            BASE_REF="$(get_base_ref "$f")"
            if [ -n "$BASE_REF" ]; then
              BASE_REF="${BASE_REF%%@*}"
              BASE_NAME="${BASE_REF##*/}"
              BASE_NAME="${BASE_NAME%%:*}"
              if [ -f "./${BASE_NAME}/Dockerfile" ]; then
                REMOTE_DIGEST="${REMOTE_DIGESTS[$BASE_REF]:-}"
                if [ -z "$REMOTE_DIGEST" ]; then
                  REMOTE_DIGEST="$(get_remote_digest "$BASE_REF" || true)"
                  REMOTE_DIGESTS["$BASE_REF"]="$REMOTE_DIGEST"
                fi
                CACHED_DIGEST="${CACHED_DIGESTS[$BASE_REF]:-}"
                if [ -z "$REMOTE_DIGEST" ] || [ -z "$CACHED_DIGEST" ] || [ "$REMOTE_DIGEST" != "$CACHED_DIGEST" ]; then
                  PULL_ARG=(--pull)
                fi
                update_digest_cache "$BASE_REF" "$REMOTE_DIGEST"
              fi
            fi

            docker buildx build \
              --push \
              "${PULL_ARG[@]}" \
              "${TAG_ARGS[@]}" \
              --cache-from type=gha \
              --cache-to type=gha,mode=max \
              "./${f}"
          done

      - name: Save base digest cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .build/base-digests.txt
          key: base-digests-${{ github.ref_name }}-${{ github.run_id }}

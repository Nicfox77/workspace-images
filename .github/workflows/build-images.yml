name: Build & Push Workspace Images

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      build_all:
        description: "Build all images (ignores change detection)"
        type: boolean
        default: false
  release:
    types: [published]

permissions:
  contents: read
  packages: write

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      folders: ${{ steps.detect.outputs.folders }}
      any: ${{ steps.detect.outputs.any }}
      build_all: ${{ steps.detect.outputs.build_all }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect image folders (Dockerfile present) + changed folders + dependency resolution
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          # Find all folders at repo root containing a Dockerfile
          mapfile -t ALL_DIRS < <(
            find . -maxdepth 2 -mindepth 2 -type f -name Dockerfile -printf '%h\n' \
              | sed 's|^\./||' \
              | awk -F/ '{print $1}' \
              | sort -u
          )

          if [ ${#ALL_DIRS[@]} -eq 0 ]; then
            echo "No Dockerfiles found."
            echo 'folders=[]' >> "$GITHUB_OUTPUT"
            echo "any=false" >> "$GITHUB_OUTPUT"
            echo "build_all=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          EVENT="${{ github.event_name }}"
          INPUT_BUILD_ALL="${{ github.event.inputs.build_all || 'false' }}"

          BUILD_ALL="false"
          if [ "$EVENT" = "workflow_dispatch" ] && [ "$INPUT_BUILD_ALL" = "true" ]; then
            BUILD_ALL="true"
          fi
          if [ "$EVENT" = "release" ]; then
            BUILD_ALL="true"
          fi

          # Build dependency graph: each image -> list of images that depend on it
          declare -A DEPENDS_ON  # image -> list of images that use it as base
          declare -A BASE_IMAGE  # image -> its base image (if any, relative path)
          
          for d in "${ALL_DIRS[@]}"; do
            if [ -f "$d/Dockerfile" ]; then
              # Extract the FROM line (first one)
              FROM_LINE=$(head -n 1 "$d/Dockerfile" | grep -i '^FROM' | head -1)
              if [ -n "$FROM_LINE" ]; then
                # Parse the base image name from FROM line
                BASE=$(echo "$FROM_LINE" | sed -E 's/^FROM[[:space:]]+([^[:space:]]+).*/\1/' | sed 's|:latest||')
                # Extract just the image name (no registry, no tag)
                BASE_NAME=$(basename "$BASE")
                # Map to our local image if it matches
                for other in "${ALL_DIRS[@]}"; do
                  if [[ "$BASE" == *"$other"* ]] || [[ "$BASE_NAME" == "$other" ]]; then
                    BASE_IMAGE["$d"]="$other"
                    DEPENDS_ON["$other"]+="$d "
                    break
                  fi
                done
              fi
            fi
          done

          # Debug: print dependency info
          echo "Dependency graph:"
          for img in "${!BASE_IMAGE[@]}"; do
            echo "  $img -> ${BASE_IMAGE[$img]}"
          done
          for base in "${!DEPENDS_ON[@]}"; do
            echo "  $base is used by: ${DEPENDS_ON[$base]}"
          done

          if [ "$BUILD_ALL" = "true" ]; then
            SELECTED=("${ALL_DIRS[@]}")
          else
            BEFORE="${{ github.event.before }}"
            AFTER="${{ github.sha }}"

            # Fallback if BEFORE is missing
            if [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
              BEFORE="$(git rev-list -n 1 "${AFTER}" 2>/dev/null || true)"
            fi

            if [ -z "$BEFORE" ]; then
              echo "Could not determine BEFORE commit; building all."
              SELECTED=("${ALL_DIRS[@]}")
            else
              mapfile -t CHANGED_FILES < <(git diff --name-only "$BEFORE" "$AFTER")
              mapfile -t CHANGED_TOP < <(printf "%s\n" "${CHANGED_FILES[@]}" | awk -F/ 'NF>1 {print $1}' | sort -u)

              SELECTED=()
              for d in "${CHANGED_TOP[@]}"; do
                if [ -f "$d/Dockerfile" ]; then
                  SELECTED+=("$d")
                fi
              done

              # Now add all images that depend on any selected base images
              # This is the key fix: when a base image is updated, also build dependents
              DEPENDENT_NEEDED=()
              for d in "${SELECTED[@]}"; do
                DEP_LIST=""
                if [[ -v "DEPENDS_ON[$d]" ]]; then
                  DEP_LIST="${DEPENDS_ON[$d]}"
                fi
                if [ -n "$DEP_LIST" ]; then
                  echo "Base image $d was changed, adding dependents: $DEP_LIST"
                  for dep in $DEP_LIST; do
                    # Check if this dependent is not already in SELECTED
                    ALREADY_SELECTED=0
                    for sel in "${SELECTED[@]}"; do
                      if [ "$sel" = "$dep" ]; then
                        ALREADY_SELECTED=1
                        break
                      fi
                    done
                    if [ $ALREADY_SELECTED -eq 0 ]; then
                      DEPENDENT_NEEDED+=("$dep")
                    fi
                  done
                fi
              done

              # Merge selected and dependents
              if [ ${#DEPENDENT_NEEDED[@]} -gt 0 ]; then
                SELECTED=("${SELECTED[@]}" "${DEPENDENT_NEEDED[@]}")
                echo "Added dependents to build: ${DEPENDENT_NEEDED[*]}"
              fi
            fi
          fi

          if [ ${#SELECTED[@]} -eq 0 ]; then
            echo "No image folders selected; nothing to build."
            echo 'folders=[]' >> "$GITHUB_OUTPUT"
            echo "any=false" >> "$GITHUB_OUTPUT"
            echo "build_all=$BUILD_ALL" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Output JSON array
          JSON='['
          first=1
          for d in "${SELECTED[@]}"; do
            if [ $first -eq 0 ]; then JSON+=','; fi
            first=0
            JSON+="\"$d\""
          done
          JSON+=']'

          echo "Selected folders: ${SELECTED[*]}"
          echo "folders=$JSON" >> "$GITHUB_OUTPUT"
          echo "any=true" >> "$GITHUB_OUTPUT"
          echo "build_all=$BUILD_ALL" >> "$GITHUB_OUTPUT"

  build:
    needs: detect
    if: needs.detect.outputs.any == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build selected images (base first) and push to GHCR
        shell: bash
        run: |
          set -euo pipefail

          OWNER_LC="$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"
          REPO_LC="workspace-images"
          PREFIX="ghcr.io/${OWNER_LC}/${REPO_LC}"

          # Parse selected folders
          FOLDERS='${{ needs.detect.outputs.folders }}'
          mapfile -t LIST < <(echo "$FOLDERS" | jq -r '.[]')

          # Order: base images first (convention: ends with -base or equals ubuntu-dev-base)
          BASES=()
          REST=()
          for f in "${LIST[@]}"; do
            if [[ "$f" == *"-base" ]] || [[ "$f" == "ubuntu-dev-base" ]]; then
              BASES+=("$f")
            else
              REST+=("$f")
            fi
          done
          ORDER=("${BASES[@]}" "${REST[@]}")

          echo "Build order: ${ORDER[*]}"

          # Tagging strategy:
          # - latest always
          # - sha-<commit> always
          # - if this is a release, also add the release tag (e.g. v1.2.3)
          RELEASE_TAG=""
          if [ "${{ github.event_name }}" = "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
          fi

          for f in "${ORDER[@]}"; do
            IMAGE="${PREFIX}/${f}"
            echo "== Building ${IMAGE} from ./${f} =="

            TAG_ARGS=(--tag "${IMAGE}:latest" --tag "${IMAGE}:sha-${GITHUB_SHA}")

            if [ -n "$RELEASE_TAG" ]; then
              TAG_ARGS+=(--tag "${IMAGE}:${RELEASE_TAG}")
            fi

            docker buildx build \
              --push \
              "${TAG_ARGS[@]}" \
              --cache-from type=gha \
              --cache-to type=gha,mode=max \
              "./${f}"
          done
